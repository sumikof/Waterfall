# TDD ワークフロー詳細ガイド

## TDD の本質

TDD は「テスト後回し」の対極にある。**テストが設計を駆動する（Test-Driven Design）**。
テストを先に書くことで、呼び出し側から見た設計を先に考える。設計が悪ければテストが書きにくいことで気づく。

原則:
- **テストファースト**: 実装コードより先にテストを書く
- **最小実装**: そのテストを通すだけの最小限のコードを書く（ハードコードで可）
- **小さなステップ**: 1テストケースずつ進める（大きく飛び越えない）
- **常に GREEN を保つ**: リファクタリング中もテストが通り続けること
- **アーキテクチャは後から**: 構造はテストを重ねる中でリファクタリングにより生まれる

---

## テストリスト（TODOリスト）の管理

TDD を始める前に **テストリスト** を作る。コードではなく「これからやること」のメモ帳。

```
テストリストの例（user-auth）
[ ] 有効なメールアドレスとパスワードでユーザーを登録できる   ← まずこれから
[ ] パスワードが8文字未満の場合は登録エラーになる
[ ] 既存のメールアドレスは重複エラーになる
[ ] メールアドレス形式が不正な場合はバリデーションエラーになる
[ ] パスワードに空白が含まれる場合はバリデーションエラーになる  ← 実装中に追加
...
```

テストリストの使い方:
- DSD-008 を元に初期リストを作る（まだコードは書かない）
- リストから **1つだけ** 選んで作業する。他は忘れてよい
- GREEN になったら ✅ をつける
- 実装中に新たなケースに気づいたら **今の作業を止めず** にリストに追記する
- リストが空になったら Done

> テストリストは「思考の外部化」。書きながら忘れるのを防ぎ、今作業中のことだけに集中できる。

---

## Red → Green → Refactor サイクル詳細

### Red フェーズ

**目的**: 意図した理由で失敗するテストを1つ書く

```
1. テストリストから1ケースを選ぶ（最も簡単な正常系から）
2. テストコードを書く（Arrange-Act-Assert の構造で）
3. テストを実行して「失敗」することを確認する
4. 失敗理由が「実装がない」ことによるものか確認する
   ✅ 正しい失敗: AssertionError, NameError, NotImplementedError
   ❌ 誤った失敗: SyntaxError, ImportError（テストコード自体のバグ）
```

### Green フェーズ

**目的**: そのテストだけを通す最小限の実装

3つの実装戦略から選ぶ（→ 「3つの実装戦略」セクション参照）。

```
1. 選んだ戦略で実装する
2. テストを実行して GREEN を確認する
3. 全テストが GREEN のままかを確認する
4. DSD との差異が生じた場合は差異メモに記録する
```

差異メモの記録フォーマット：
```
[差異メモ]
- 対象: {クラス名/関数名}
- DSD 仕様: {DSD に記載された内容}
- 実装内容: {実際の実装}
- 理由: {差異が生じた理由}
- 影響: {他への影響、要確認事項}
```

### Refactor フェーズ

**目的**: 振る舞いを変えずにコードを整える

チェックリスト（DSD-007 に沿って確認）：

```
□ 命名規則に従っているか（DSD-007 参照）
□ 重複コードを排除できるか
□ 関数/メソッドが単一責任になっているか
□ マジックナンバーが定数化されているか
□ エラーハンドリングが DSD-001/002 の仕様通りか
□ ログ出力が設計通りか
□ 全テストが GREEN のままか（必ず確認）
```

---

## 3つの実装戦略

Green フェーズでは以下の3つから状況に応じて選ぶ：

| 戦略 | 使いどき | やること |
|---|---|---|
| **仮実装** | 正しい実装が不明確・不安なとき | ハードコードで通す → 三角測量で汎化 |
| **三角測量** | 仮実装のハードコードを崩す | ハードコードが失敗する2つ目のテストを追加 |
| **明白な実装** | 正しい実装がすぐに分かるとき | 最初から正しい実装を書く |

> 迷ったときは仮実装を選ぶ。急いで汎化しようとすると TDD のリズムが崩れる。

### 仮実装（Fake it 'til you make it）

```python
# テスト: test_TC001 add(1, 2) == 3
def add(a, b):
    return 3  # ハードコード。次のテストが汎化を強制する
```

### 三角測量（Triangulation）

仮実装のハードコードを壊す2つ目の例を追加することで汎化を強制する。

```python
# TC-001: add(1, 2) == 3  → return 3 で GREEN
# TC-002: add(2, 3) == 5  → return 3 では失敗 → 汎化を強制される

def add(a, b):
    return a + b  # 三角測量により汎化
```

三角測量の選び方:
- ハードコードを破る新しい入力値（別の数値・ゼロ・負値）を使う
- 汎化の方向が1つに決まるように設計する
- 「正常系→境界値→異常系」の順が自然

### 明白な実装（Obvious Implementation）

実装が明らかなときはハードコードを経ずに書いてよい。

```python
# add の実装が自明なとき
def add(a, b):
    return a + b  # 最初から正しい実装
```

**ただし GREEN にならなかった場合は、過信だったことを意味する。**
その場合は仮実装に戻り、三角測量でアプローチし直す。

---

## テストの構造: Arrange-Act-Assert（3A）

テストは必ず3つのブロックで構成する：

```python
def test_TC001_有効なメールアドレスでユーザーを登録できる():
    # Arrange（前提条件の準備）
    repo = InMemoryUserRepository()
    service = UserService(repo)

    # Act（操作の実行）
    result = service.register("user@example.com", "Password123")

    # Assert（結果の検証）
    assert result.is_success is True
    assert repo.find_by_email("user@example.com") is not None
```

原則:
- 1テストに検証する振る舞いは1つ
- Arrange が膨らんだら共通化（fixture / setUp）を検討
- Assert が複数行になるのは同一の振る舞いを検証する場合は許容

### アサートファースト（Assert First）

テストを書くとき、**アサートから先に書いて逆算する**。

```python
# Step 1: まずゴールを書く
assert result.email == "user@example.com"

# Step 2: result はどこから来る？
result = service.register("user@example.com", "Password123")

# Step 3: service はどこから来る？
service = UserService(InMemoryUserRepository())
```

アサートから逆算することで「何をテストしたいか」が明確になる。
セットアップが複雑になるほど、テスト自体の設計を見直すシグナルでもある。

---

## テスト名：振る舞いを記述する

テスト名は実装の詳細ではなく **振る舞い（Behavior）** を表現する。
テスト名はそのまま仕様書として読める品質を目指す。

```python
# ❌ 実装の詳細を書いてしまっている
def test_validate_returns_false():
    ...

def test_register_raises():
    ...

# ✅ 振る舞いを書く（Given-When-Then を意識）
def test_TC002_パスワードが8文字未満の場合バリデーションエラーになる():
    ...

def test_TC003_登録済みメールアドレスで登録するとDuplicateErrorが発生する():
    ...
```

命名の指針:
- 「〜の場合、〜になる」という条件→結果の形が読みやすい
- DSD-008 のテストケースIDを先頭に付けてトレーサビリティを保つ
- 失敗したテスト名だけで何が壊れたか分かるようにする

---

## FIRST 原則

テストが備えるべき5つの性質：

| 原則 | 意味 | 満たせない場合の対策 |
|---|---|---|
| **Fast** | ミリ秒で動く | 遅い依存はテストダブルに置き換える |
| **Independent** | テスト同士が影響し合わない | 共有状態をなくす。setUp/tearDown で初期化する |
| **Repeatable** | どの環境でも同じ結果 | 時刻・乱数・外部API を制御下に置く |
| **Self-validating** | Pass/Fail が自明 | アサートで検証する（print デバッグ・目視確認をしない） |
| **Timely** | 実装直前に書く | TDD のサイクルを守る（後回しにしない） |

---

## テストダブルの種類と使い分け

外部依存を制御するための代替オブジェクト（Test Double）には5種類ある：

| 種類 | 目的 | 典型的な使いどき |
|---|---|---|
| **Dummy** | 引数の穴埋め（実際には使われない） | 必須パラメータだがテストで使わないとき |
| **Stub** | 間接入力を固定値で制御 | リポジトリやAPIの「返り値」をコントロールしたいとき |
| **Fake** | 実際に動く軽量な代替実装 | InMemoryRepository など。本番環境には使えないが動く |
| **Spy** | 呼び出しを記録するスタブ | 後からどう呼ばれたか確認したいとき |
| **Mock** | 期待呼び出しを事前設定し、呼ばれなければテスト失敗 | 「このメソッドがこの引数で呼ばれたこと」を検証 |

Stub と Mock の違い（最重要）：
```python
# Stub: 間接入力を制御（what to return）
user_repo.find_by_id.return_value = User(id=1, name="Alice")

# Mock: 間接出力を検証（how it was called）
mailer.send_welcome_email.assert_called_once_with("user@example.com")
```

> Mock はテストと実装の結合度が高くなる。
> 「どう呼ばれたか」ではなく「何が変わったか」で検証できるなら、
> Stub + 状態検証（State Verification）を優先する。

テストダブルの導入タイミング：
```
外部依存が増えてテストが遅くなった / 非決定的になった → その時点でダブル化
最初からモックを作り込まない
```

---

## バックエンド TDD の実践パターン

### 構造はテストから自然に生まれる

TDD では事前にレイヤー構造を決めない。テストを1つ書くたびに最小限のコードを追加し、**リファクタリングの中で自然にレイヤーが分離していく。**

```
イテレーション 1〜3: 関数1つで動く（レイヤーなし）
イテレーション 4〜6: ロジックとDBアクセスが混在してきたら分離
イテレーション 7〜: テストのダブル化が必要になったらリポジトリ抽象化
```

> DSD-001 のアーキテクチャはゴール（あるべき最終構造）として参照する。
> ただし実装はそこに向けて小さく育てる。最初から作らない。

### API テストパターン（DSD-003 に基づく）

```
各エンドポイントに対して以下のテストケースを網羅する：
- 正常系: 正しいリクエスト → 期待するレスポンスとステータスコード
- バリデーションエラー: 不正な入力 → 400 Bad Request
- 認証エラー: 未認証リクエスト → 401 Unauthorized
- 権限エラー: 権限不足 → 403 Forbidden
- Not Found: 存在しないリソース → 404 Not Found
- 重複エラー: 既存データとの衝突 → 409 Conflict
```

---

## フロントエンド TDD の実践パターン

### コンポーネントは最小単位から育てる

```
イテレーション 1: 静的レンダリングのテスト（props を受け取って表示）
イテレーション 2: ユーザー操作のテスト（クリック・入力）
イテレーション 3: API 連携のテスト（テストダブルで）
イテレーション 4: エラー・空状態のテスト
```

> ページ全体・ルーティングのテストは最後。最小コンポーネントが GREEN になってから組み合わせる。

### コンポーネントテストのチェックリスト

```
□ 正常データでのレンダリング
□ ローディング状態の表示
□ エラー状態の表示（API エラー時）
□ 空データ時の表示（0件リスト等）
□ ユーザー操作（クリック・入力・送信）
□ バリデーションエラーメッセージの表示
□ アクセシビリティ（aria-label 等）
```

---

## DB マイグレーション TDD

DSD-004 のテーブル定義をもとにマイグレーションを作成する：

```
1. マイグレーションファイルを作成する
2. マイグレーション実行テストを書く（テスト DB に対して実行・ロールバック）
3. マイグレーション実行後のスキーマが DSD-004 の定義通りか確認する
4. ロールバックスクリプトが正しく動作するか確認する
5. IMP-004 にスクリプト一覧・実行順序・ロールバック手順を記載する
```

---

## アンチパターン

TDD を形骸化させる典型的なミスを避ける：

```
❌ テストリストを作らずに進める
   → まず DSD-008 を TODO リストに変換する。思いついたケースはすぐリストに追記する

❌ テストをまとめて書く
   → 1サイクル1テスト。複数まとめると GREEN の意味が薄れる

❌ 最初から汎用的な実装を書く
   → まず仮実装。汎化は三角測量が強制したときに行う

❌ 明白な実装のつもりで書いて GREEN にならない
   → 過信だった証拠。仮実装に戻り、三角測量でアプローチする

❌ アサートを最後に書く
   → アサートから書いて逆算する。セットアップが膨らんだら設計を疑う

❌ テスト名に実装の詳細を書く
   → テスト名は振る舞い（〜の場合〜になる）で記述する

❌ 事前にアーキテクチャを全部設計する
   → 構造はリファクタリングで育てる。DSD-001 はゴールとして参照するだけ

❌ DSD を全部読んでから実装を始める
   → 現在のテストに必要な箇所だけ読む。読みすぎると先取り実装になる

❌ テストが RED のまま次のテストに進む
   → 必ず GREEN を確認してから次へ。RED のまま進むと何が壊れているか分からなくなる

❌ Refactor で振る舞いを変える
   → リファクタリングは構造の整理のみ。全テスト GREEN のまま維持する

❌ Mock を多用して実装詳細に結合する
   → 「どう呼ばれたか」ではなく「何が変わったか」で検証できるなら Stub + 状態検証を優先する
```

---

## 実装完了の定義（Done の基準）

機能の TDD サイクル完了とみなす条件：

```
□ テストリストが全て ✅（DSD-008 の全テストケースが GREEN）
□ DSD-007 のコーディング規約に準拠している
□ DSD-001/002 の設計と照合し、差異を IMP-001/002 に記録した
□ コードレビュー基準（DSD-007 参照）を満たしている
□ IMP-001/002（実装・単体テスト完了報告書）を作成した
  └ テストケース一覧（DSD-008 対応）・カバレッジ・テストコード配置を含む
□ TDD 中に発見した不具合を IMP-005（TDD不具合管理票）に記録した
□ DB 変更がある場合: IMP-004_FEAT-{NNN}_draft.md にマイグレーション下書きを作成した
□ 初回構築の場合: IMP-003 に環境構築手順を記載した
```
